def groverDiff[n:!â„•](records:uint[n])mfree:uint[n] {
	// Hadamard gates to all data qubits
	for k in [0..n) { records[k] := H(records[k]); }

	// Multi-Controlled phase gate
	if records != 0 {
		phase(Ï€);
	}

	// Hadamard gates to all data qubits
	for k in [0..n) { records[k] := H(records[k]); }

	return records;
}

def search[n:!â„•](f:!(uint[n] !-> lifted ğ”¹)):uint[n] {
	// Calculate number of iterations
	num_iter := floor(Ï€/(4 * asin(2^(-n/2))));

	// Initialize the record pointer to Zero
	records := 0:uint[n];

	// Put the record pointer register in superposition
	// of all possible states.
	for k in [0..n) { records[k] := H(records[k]); }

	// Implement the oracle f() and groverDiff()
	// `num_iter` times for amplitude amplification of
	// the |keyâŸ© or |Ï‰*âŸ© state
	for k in [0..num_iter){
		if f(records) { phase(Ï€); }
		records := groverDiff(records);
	}

	// Return the result
	return records;
}

def main() {
	// To generate a random number every time we run the program.
	key := measure(H(0:ğ”¹), H(0:ğ”¹), H(0:ğ”¹), H(0:ğ”¹), H(0:ğ”¹)) as !uint[5];
	print(key);

	// Lambda function to create oracle (or BlackBox function)
	createOracle := lambda[n:!â„•](key:!uint[n])(x:uint[n])lifted:ğ”¹ {
		anc := 0:ğ”¹;
		r := 1:ğ”¹;

		// Multi-Controlled X gate
		for i in [0..n) {
			if key[i] { r &= x[i]; }
			else { r &= X(x[i]); }
		}
		if r { anc := X(anc); }

		forget(r);
		return anc;
	};

	// Generating the oracle.
	f := createOracle(key);

	return search(f);
}
