def predictNumber[n:!â„•](f:!(const uint[n] !-> ğ”¹)):!â„• {
	qr := 0:uint[n];

	// Put the register in superposition
	for i in [0..n) { qr[i] := H(qr[i]); }

	// Call BlackBox function
	measure(f(qr));

	// Collapse the wave-function
	for i in [0..n) { qr[i] := H(qr[i]); }

	// Measure the result
	return measure(qr) as !â„•;
}

def main() {
	// Generate a random number
	key := measure(H(0:ğ”¹), H(0:ğ”¹), H(0:ğ”¹), H(0:ğ”¹), H(0:ğ”¹)) as !uint[5];

	// Lambda function for creating the oracle (BlackBox function)
	createOracle := lambda[n:!â„•](key:!uint[n])(const x:uint[n]):ğ”¹ {
		anc := H(X(0:ğ”¹));

		// Phase kick-back induced on data qubits using ancilla qubit.
		for i in [0..n) {
			anc xorb= key[i] & x[i];
		}

		return anc;
	};

	f := createOracle(key);

	return (key, predictNumber(f));
}
